Goroutines & channels III
Peeking behind the magic curtain
07 Oct 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have three talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go* (23/09/2020)
introduces and covers the basics.
*Apprentice* *to* *Illusionist:* *channels* *deep* *dive* (30/09/2020)
discusses more complex channels operations, their usage and their limitations.
*Master* *Illusionist:* *concurrency* *patterns* (07/10/2020)
presents Go concurrency patterns and real world examples.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`.

.link https://godoc.org/golang.org/x/tools/present

As we have not made them public, you can only see them locally.
To see them and run the code examples you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` `-use_playground` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks-session3.slide#1

* Master Illusionist: concurrency patterns

.image https://media.giphy.com/media/3o6Zthq1yAc3Fdbsis/giphy.gif _ 600

* Agenda - Magic show III
In the next 45-60min we will cover:

- Recap of channels
- Signalling to Goroutines that work is finished
- Pipelines
- The Go race detector
- Real world examples
- Self-Study: Fan-out, Fan-in

* Recap - channels & synchronization
In the past 2 weeks, we've gone on an epic journey with Goroutines and channels.
The key takeaways have been:

- *Goroutines* are *lightweight* threads that allow our programs to do more than 1 task. This allows us to use resources optimally
- *Channels* are like pipes that we can send resources/information through. *Sends* and *receives* are blocking.
- Goroutines communicate via channels, which allow us to send information and avoid data races
- The `sync` package contains the `Mutex` and `WaitGroup`. These are locks that can be used for resource locking and goroutine synchronization
- Channels *should* be used for resource sharing, while locks can be used for synchronization when no other information is shared


* Recap - Closing channels
In session 2, we discussed closing channels to signal that no more values are going to be sent through.

A closed channel will *immediately* return the zero value of that type when read from.
Sending to a closed channel *panics*.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

The `for` `range` exits and stops receiving values once the channel is closed.

* Unidirectional channels
When using channels as function parameters, you can specify if a channel is meant to only send or receive values.
This specificity increases the type-safety of the program. A compile error will be raised when attempting an unsupported operation.

By default a channel is bidirectional, but we can create a unidirectional channel also.
We are allowed to convert a bidirectional channel into the unidirectional channel, or in other words, you can convert a bidirectional channel into a receive-only or send-only channel, but vice versa is not possible.

.image https://media.giphy.com/media/xUPJPtOPpj7konQPZu/giphy.gif _ 350

* Passing unidirectional channels to functions

.play code-session3/unidirectional_channel_syntax.go /START OMIT/,/END OMIT/

* Concurrency Patterns
Now that we understand the basics of Goroutines, channels and synchronization, let's have a look at some common problems and patterns.
We will have a look at the following patterns:

- Signalling that work is finished
- Pipelines: processing data in a series of stages connected by channels, where each stage is a group of goroutines running the same function
- Fan-out, Fan-in: Multiplexing and Demultiplexing to optimise resource usage

* The Channel Card Shuffle - the shuffle

.code code-session3/channel_shuffle.go /START OMIT/,/END OMIT/

* The Channel Card Shuffle - the trick

.play code-session3/failed/channel_shuffle.go /START OMIT/,/END OMIT/

* Oh noes! The shuffle has exploded!
Closing the cards channel to signal we no longer wish to receive cards has backfired.
Sends on closed channels panic and this has caused our shuffle to go awry.

.image https://media.giphy.com/media/3orif5bwPOWLelQoc8/giphy.gif _ 450

* Signalling to Goroutines that work is finished
This is a common problem out in the wild.
A solution is to use a signal channel. This is a channel whose sole purpose is to signal, not transfer information.

`signal:=` `make(chan` `struct{})`

The goroutine that is sending to the channel should be the one to close the channel, but we can close an *additional* channel to tell the goroutine to stop.
This will avoid the panic we saw in the channel shuffle.
We can use the `select` we saw last time to listen to the signal channel

* The Signal Channel Card Shuffle - the shuffle

.code code-session3/channel_signal_shuffle.go /START OMIT/,/END OMIT/

* The Signal Channel Card Shuffle - the trick

.play code-session3/success/channel_shuffle.go /START OMIT/,/END OMIT/

* What a great shuffle!
Closing the signal channel allows us to tell the magician to stop sending cards without causing a panic. Hurray!

.image https://media.giphy.com/media/1AfMNaccBB9uI6Uq6G/giphy.gif _ 450

* Pipelines
A *pipeline* is a series of stages connected by channels, where each stage is a group of goroutines running the same function.

In each stage, the goroutines:
- receive values from upstream via inbound channels
- perform some function on that data, usually producing new values
- send values downstream via outbound channels

Each stage has any number of inbound and outbound channels, except the first and last stages, which have only outbound or inbound channels, respectively.
The first stage is sometimes called the *source* or *producer*; the last stage, the *sink* or *consumer*.

* The Pipeline Straitjacket Escape - the performers

.code code-session3/pipeline_performers.go /START OMIT/,/END OMIT/

* The Pipeline Straitjacket Escape - the trick

.play code-session3/success/pipeline_trick.go /START OMIT/,/END OMIT/

* The Go race detector
Race conditions are elusive bugs that can be difficult to find and debug.
The Go race detector is integrated with the go tool chain.

.code code-session3/go_race_syntax.go /START OMIT/,/END OMIT/

The race detector is integrated with the go tool chain.
When the `-race` command-line flag is set, the compiler instruments all memory accesses with code that records when and how the memory was accessed, while the runtime library watches for unsynchronized accesses to shared variables.
When such "racy" behavior is detected, a warning is printed.

* Remember the racy infinite hat from session 1?

.play code-session3/failed/racy_infinite_hat.go /START OMIT/,/END OMIT/

* Let's see what the go race detector has to say about it!

.code code-session3/go_race_output.go /START OMIT/,/END OMIT/

* Race detector in Production

The race detector can detect race conditions only when they are actually triggered by running code, which means it's important to run race-enabled binaries under realistic workloads.
However, race-enabled binaries can use ten times the CPU and memory, so it is impractical to enable the race detector all the time.

One way out of this dilemma is to run some tests with the race detector enabled.
Load tests and integration tests are good candidates, since they tend to exercise concurrent parts of the code.
Another approach using production workloads is to deploy a single race-enabled instance within a pool of running servers.

* Real life examples
Common uses of goroutines are:

- Background processing of large files
- Handling user requests in web servers
- Pushing tracking events/logs in the background

* Self-study: Fan out, Fan in
Multiple functions can read from the same channel until that channel is closed; this is called *fan-out*. This provides a way to distribute work amongst a group of workers to parallelize CPU use and I/O.

A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that's closed when all the inputs are closed. This is called *fan-in*.

.image https://media.giphy.com/media/D0WOL0ogZIoG4/giphy.gif _ 350

* Self-study: The Fan Infinite Hat - the concealers

.code code-session3/fan_infinite_hat_concealers.go /START OMIT/,/END OMIT/

* Self-study: The Fan Out Infinite Hat - the revealers

.code code-session3/fan_infinite_hat_revealers.go /START OMIT/,/END OMIT/

* Self-study: The Fan Out Infinite Hat - the trick

.play code-session3/success/fan_infinite_hat.go /START OMIT/,/END OMIT/

* Self-study: The hat is a lie!
We have modelled the infinite hat trick without even representing a hat!
The concealers fanned out by pushing items to their own channel, then the revealer fanned merging all the items back and revealing them!

.image https://media.giphy.com/media/LpLd2NGvpaiys/giphy.gif _ 450

* Useful links
Go by example: Channel directions

.link https://gobyexample.com/channel-directions

Starting and stopping things with a signal channel

.link https://medium.com/@matryer/golang-advent-calendar-day-two-starting-and-stopping-things-with-a-signal-channel-f5048161018

Go Concurrency Patterns: Pipelines and cancellation

.link https://blog.golang.org/pipelines

The Go Blog - Introducing the Go Race Detector

.link https://blog.golang.org/race-detector

* This concludes our epic journey!
Thank you to all my colleagues at Cytora for listening and supporting me during this Goroutines & Channels 3 talk series.

.image gophermicdrop.png _ 400