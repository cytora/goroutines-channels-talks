Goroutines & channels III
Peeking behind the magic curtain
07 Oct 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have three talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go* (23/09/2020)
introduces and covers the basics.
*Apprentice* *to* *Illusionist:* *channels* *deep* *dive* (30/09/2020)
discusses more complex channels operations, their usage and their limitations.
*Master* *Illusionist:* *concurrency* *patterns* (07/10/2020)
presents Go concurrency patterns and real world examples.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`.

.link https://godoc.org/golang.org/x/tools/present

As we have not made them public, you can only see them locally.
To see them and run the code examples you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` `-use_playground` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks-session3.slide#1

* Master Illusionist: concurrency patterns

.image https://media.giphy.com/media/3o6Zthq1yAc3Fdbsis/giphy.gif _ 600

* Agenda - Magic show III
In the next 45-60min we will cover:

- Recap of channels
- Signalling to Goroutines that work is finished
- Pipelines
- Fan-out, Fan-in
- The Go race detector
- Real world examples

* Recap - channels & synchronization
In the past 2 weeks, we've gone on an epic journey with Goroutines and channels.
The key takeaways have been:

- *Goroutines* are *lightweight* threads that allow our programs to do more than 1 task. This allows us to use resources optimally
- *Channels* are like pipes that we can send resources/information through. *Sends* and *receives* are blocking.
- Goroutines communicate via channels, which allow us to send information and avoid data races
- The `sync` package contains the `Mutex` and `WaitGroup`. These are locks that can be used for resource locking and goroutine synchronization
- Channels *should* be used for resource sharing, while locks can be used for synchronization when no other information is shared

* Concurrency Patterns
Now that we understand the basics of Goroutines, channels and synchronization, let's have a look at some common problems and patterns.
We will have a look at the following patterns:

- Signalling that work is finished
- Pipelines: processing data in a series of stages connected by channels, where each stage is a group of goroutines running the same function
- Fan-out, Fan-in: Multiplexing and Demultiplexing to optimise resource usage

* Recap - Closing channels
In session 2, we discussed closing channels to signal that no more values are going to be sent through.

A closed channel will *immediately* return the zero value of that type when read from.
Sending to a closed channel *panics*.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

The `for` `range` exits and stops receiving values once the channel is closed.

* Unidirectional channels
When using channels as function parameters, you can specify if a channel is meant to only send or receive values.
This specificity increases the type-safety of the program. A compile error will be raised when attempting an unsupported operation.

By default a channel is bidirectional, but we can create a unidirectional channel also.
We are allowed to convert a bidirectional channel into the unidirectional channel, or in other words, you can convert a bidirectional channel into a receive-only or send-only channel, but vice versa is not possible.

.image https://media.giphy.com/media/xUPJPtOPpj7konQPZu/giphy.gif _ 350

* Passing unidirectional channels to functions

.play code-session3/unidirectional_channel_syntax.go /START OMIT/,/END OMIT/

* The Channel Card Shuffle - the shuffle

.code code-session3/channel_shuffle.go /START OMIT/,/END OMIT/

* The Channel Card Shuffle - the trick

.play code-session3/failed/channel_shuffle.go /START OMIT/,/END OMIT/

* Oh noes! The shuffle has exploded!
Closing the cards channel to signal we no longer wish to receive cards has backfired.
Sends on closed channels panic and this has caused our shuffle to go awry.

.image https://media.giphy.com/media/3orif5bwPOWLelQoc8/giphy.gif _ 450

* Signalling to Goroutines that work is finished
This is a common problem out in the wild.
A solution is to use a signal channel. This is a channel whose sole purpose is to signal, not transfer information.

`signal:=` `make(chan` `struct{})`

The goroutine that is sending to the channel should be the one to close the channel, but we can close an *additional* channel to tell the goroutine to stop.
This will avoid the panic we saw in the channel shuffle.
We can use the `select` we saw last time to listen to the signal channel

* The Signal Channel Card Shuffle - the shuffle

.code code-session3/channel_signal_shuffle.go /START OMIT/,/END OMIT/

* The Signal Channel Card Shuffle - the trick

.play code-session3/success/channel_shuffle.go /START OMIT/,/END OMIT/

* What a great shuffle!
Closing the signal channel allows us to tell the magician to stop sending cards without causing a panic. Hurray!

.image https://media.giphy.com/media/1AfMNaccBB9uI6Uq6G/giphy.gif _ 450

* Pipelines
A *pipeline* is a series of stages connected by channels, where each stage is a group of goroutines running the same function.

In each stage, the goroutines:
- receive values from upstream via inbound channels
- perform some function on that data, usually producing new values
- send values downstream via outbound channels

Each stage has any number of inbound and outbound channels, except the first and last stages, which have only outbound or inbound channels, respectively.
The first stage is sometimes called the *source* or *producer*; the last stage, the *sink* or *consumer*.

* The pipeline jugglers

* Fan out, Fan in
Multiple functions can read from the same channel until that channel is closed; this is called *fan-out*. This provides a way to distribute work amongst a group of workers to parallelize CPU use and I/O.

A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that's closed when all the inputs are closed. This is called *fan-in*.

.image https://media.giphy.com/media/D0WOL0ogZIoG4/giphy.gif _ 350

* The Fan Out Infinite Hat - the performers

.code code-session3/pipeline_infinite_hat.go /START OMIT/,/END OMIT/

* The Fan Out Infinite Hat - the trick

.play code-session3/success/pipeline_infinite_hat.go /START OMIT/,/END OMIT/

* The hat is a lie!
We have modelled the infinite hat trick without even representing a hat!
The concealers fanned out by pushing items to the buffered channel, then the revealer fanned in by reading all the items.

.image https://media.giphy.com/media/LpLd2NGvpaiys/giphy.gif _ 450

* Useful links
Go by example: Channel directions

.link https://gobyexample.com/channel-directions

Futures/Promises in Golang

.link https://medium.com/strava-engineering/futures-promises-in-the-land-of-golang-1453f4807945

Starting and stopping things with a signal channel

.link https://medium.com/@matryer/golang-advent-calendar-day-two-starting-and-stopping-things-with-a-signal-channel-f5048161018

Go Concurrency Patterns: Pipelines and cancellation

.link https://blog.golang.org/pipelines

* This concludes our epic journey!
Thank you to all my colleagues at Cytora for listening and supporting me during this Goroutines & Channels 3 talk series.

.image gophermicdrop.png _ 400