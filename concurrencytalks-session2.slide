Goroutines & channels II
Peeking behind the magic curtain
30 Sep 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have three talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go* (23/09/2020)
introduces and covers the basics.
*Apprentice* *to* *illusionist:* *advanced* *channels* *usage* (30/09/2020)
discusses more complex channels operations and their usage.
*Master* *illusionist:* *concurrency* *patterns* (07/10/2020)
presents Go concurrency patterns and real world examples.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`.

.link https://godoc.org/golang.org/x/tools/present

As we have not made them public, you can only see them locally.
To see them and run the code examples you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` `-use_playground` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks-session2.slide#1

* Apprentice to Illusionist: advanced channels usage

.image https://media.giphy.com/media/XKjcTrzElUjsaeQ1eg/giphy.gif _ 600

* Agenda - Magic show II
In the next 45-60min we will cover:

- Recap of pointers
- Recap of sending & receiving on channels
- Closing channels
- The for range
- The `select` keyword
- WaitGroups vs Channels

* Magic refresher - pointer operators
A *pointer* is a memory address to a variable.

The `&` operator generates a pointer to its operand. If the operand is of type `T`, then the type of the pointer is `*T`.

The `*` operator is used to  *dereference* the pointer from its memory address to the current value at that address.

The zero value of pointers is `nil`. Attempting to dereference a `nil` pointer will cause a `panic` ... and not at the Disco!

* Abracadabra!

.play code-session2/pointer_basics.go /START OMIT/,/END OMIT/

* Magic refresher - pointers & argument passing

- Arguments to functions are passed by value in Go. A copy of the argument is made inside function scope
- Any changes we make to the copy will be lost, as the copy is destroyed by the garbage collector once the function exits
- Passing pointers to functions allow us to make permanent changes to variables
- The rules of pointers apply to *method* *receivers* also, as they can be considered the first *implicit* argument of methods
- Pointers themselves are passed by value, so reassigning the pointer to a different variable address will not persist outside the scope of the function
- Unless the object is large, passing by value is significantly cheaper/more performant than passing by pointer as we don't have to chase memory allocations

* The Rabbit Hat-trick - the hat

.code code-session2/rabbit_hat.go  /START OMIT/,/END OMIT/

* The Rabbit Hat-trick - the trick

.play code-session2/failed/pointers_argument_passing.go  /START OMIT/,/END OMIT/

* The rabbit has escaped the hat!
The rabbit is put inside a copy of the hat, which only lives inside function scope.
The rabbit is successfully placed inside the copy-hat, but the original hat remains empty.
The same rules were valid with method receivers and the flowers also elude the hat.

.image https://media.giphy.com/media/fYfeQAOD8pSjN7M0jY/giphy.gif _ 500

* The Pointer Rabbit Hat-trick - the hat
Let's try the rabbit hat trick again by making use of pointers...

.code code-session2/pointer_rabbit_hat.go  /START OMIT/,/END OMIT/

* The Pointer Rabbit Hat-trick - the trick

.play code-session2/success/pointers_argument_passing.go  /START OMIT/,/END OMIT/

* Finally, the rabbit stays put inside the hat!

Once we passed pointers to the hat, changes persisted outside of function scope!

.image https://media.giphy.com/media/MFlhfP81IpKgaN50fq/giphy.gif _ 300

* The Impossible Rabbit Hat Trick - the hat

.code code-session2/impossible_rabbit_hat.go /START OMIT/,/END OMIT/

* The Impossible Rabbit Hat Trick - the trick

.play code-session2/failed/pointers_reassignment.go /START OMIT/,/END OMIT/

* Not even Penn & Teller can do this one!
The Impossible Rabbit Hat trick can never be performed unless we again pass a pointer to the pointer, but let's not go down that rabbit hole.
Pointers themselves are passed by value so the hat swap will never work!

.image https://media.giphy.com/media/O5LDFyEHkMhqg/giphy.gif _ 450

* The WaitGroup Bullet Catch from Session I

.play code-session2/success/wg_magic_show.go /START OMIT/,/END OMIT/

* Just as majestic as the first time we saw it!
The Waitgroup Bullet Catch makes use of the `sync.WaitGroup` to make sure that the assistant and magician goroutines execute in an order that makes sense ... and doesn't ruin the magician's reputation!

However, the trick also depends on our friends the pointers.
A pointer to the `sync.WaitGroup` is passed to each goroutine and we mentioned this was *very* important.

Let see what happens without the pointers...

* The WaitGroup Bullet Catch minus pointers

.play code-session2/failed/wg_magic_show.go /START OMIT/,/END OMIT/

* Woah, maybe pointers are the real magicians!
Without the pointers, each goroutine invokes `Done()` on a copy - `WaitGroup` and the `main` goroutine is never released. The Go runtime sees this deadlock and triggers a panic to shut down the hanging program.

Remember, always pass your locks by pointer. The same problem could be replicated with the `sync.Mutex` from the Infinite Hat example from session I.

.image https://media.giphy.com/media/1itbWbkMaweuhH5f6C/giphy.gif _ 350

* Recap - Channel basics
Now let's leave behind the world of pointers, rabbits and hats for a little while and go back to our *channels*.
As we learned in the last session:

- *Unbuffered* channels are initialized with `make(chan` `T)`. *Buffered* channels are given a capacity `make(chan` `T,capacity)`
- Channel sends are blocking until there is space in the channel to send the value ie until channel is not full
- Channel receives are blocking until there is a value to be read from the channel
- Channels can be used for synchonization as well as data communication due to the blocking nature of sends and receives

* The Channel Teleporting coin - the coin performer

.code code-session2/coin_performer.go /START OMIT/,/END OMIT/

* The Channel Teleporting coin - the trick

.play code-session2/success/channels_sends_receives.go /START OMIT/,/END OMIT/

* How did that coin move so fast!
The performers sent the coin between themselves very quickly.
The buffered channel kept the coin at the end, even if the other magician finished and has taken his bow.

The real trick is in the magic of the channels!

.image https://media.giphy.com/media/h8D1M8clhWfBmK16wb/giphy.gif _ 550

* Closing channels
Senders have the ability to close the channel to notify receivers that no more data will be sent on the channel.
A closed channel will *immediately* return the zero value of that type when read from.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

In the above statement `ok` is true if the value was received by a successful send operation to a channel. If `ok` is false it means that we are reading from a closed channel.

Sending to a closed channel will *panic*. This is to ensure that goroutines are not blocked waiting to send values to a closed channel.

* The Channel Card Shuffle - the shuffle

.code code-session2/channel_shuffle.go /START OMIT/,/END OMIT/

* The Channel Card Shuffle - the trick

.play code-session2/success/channel_close_magic_trick.go /START OMIT/,/END OMIT/

* Channels and the for range
The *for* *range* form of the for loop can be used to receive values from a channel until it is closed. Once the channel is closed, the loop automatically exits.

* The for range Card Shuffle
.play code-session2/success/for_range_magic_trick.go /START OMIT/,/END OMIT/

* What a great shuffle!
A channel was used to communicated with the magician and tell him when to stop shuffling. The channel is closed when we are done picking card and the loop exits.
A separate channel was used to ensure that the goroutine finished its work before exiting. `main` waits for a value from this separate channel before exiting.
Closing the channel will make it immediately return the zero value, unblocking `main`

.image https://media.giphy.com/media/Ok2oKUe5Mnq3m60vFJ/giphy.gif _ 350

* The select keyword

The `select` statement is used to choose from multiple send/receive channel operations.
The `select` statement blocks until one of the send/receive operation is ready.
If multiple operations are ready, one of them is chosen at random.
The `default` case in a `select` statement is executed when none of the other case is ready. This is generally used to prevent the `select` statement from blocking.

.code code-session1/channels/select_syntax.go /START OMIT/,/END OMIT/

* The Select Sawing a Woman in Half Trick

.play code-session2/success/channels_selects.go /START OMIT/,/END OMIT/