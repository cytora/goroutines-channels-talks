Goroutines & channels
Peeking behind the magic curtain
23 Sep 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have two talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go*
introduces and covers the basics.
*Apprentice* *to* *illusionist:* *concurrency* *patterns*
takes these basics out for a spin and lets us explore them further.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`, as it allows us to run `Go` code straight into the slide deck.

.link https://godoc.org/golang.org/x/tools/present

To see them and run the code examples locally you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks.slide#1

* Easy magic tricks: concurrency basics in Go
.image https://media.giphy.com/media/JOXzH8WcOgR8PLBqtm/giphy.gif _ 500
* Agenda - Magic show I
In the next 45-60min we will cover:

- Concurrency vs parallelism
- What is a goroutine?
- Common uses of goroutines
- Goroutines basics
- The WaitGroup
- Channels
- The Select keyword

* Concurrency vs parallelism
Everyone knows that `Go` is designed for concurrency, but what is *concurrency*?

*Concurrency*:
- the composition of independently executing processes
- dealing with lots of things at once
- execution can complete in any given order decided by the scheduler

*Parallelism*:
- the simultaneous execution of (possibly related) computations.
- doing lots of things at once


* The concurrent & parallel magician

The magician shuffles the card deck and entertains his audience with jokes using *paralellism*. He is doing both at the same time.

The magician shuffles the card deck and steals a card using *concurrency*. We are not sure the order in which these events happened.

.image https://media.giphy.com/media/UV4liSdOaKdw3V9HGI/giphy.gif _ 350

* What is a Goroutine?
-  In Go, concurrency is achieved by using Goroutines. Goroutines are functions or methods which can run concurrently with other methods and functions
- Goroutines are sometimes called _lightweight_ _threads_
- Goroutines require *2kb* of memory, while threads require *1Mb* (~500x more)
- Unlike threads, they are managed by the `Go` runtime not the OS
- Unlike threads, they are *cooperatively* scheduled and they periodically yield control

.image https://media.giphy.com/media/uNE1fngZuYhIQ/giphy.gif _ 600

* Cool, but why should I care?

Common uses of goroutines are:

- Background processing of large files
- Handling user requests in web servers
- Pushing tracking events/logs in the background

Let's give it up for our good friends, the goroutines!

.image https://media.giphy.com/media/UDjF1zMreMld6/giphy.gif _ 450

* The go keyword
Starting go routines is easy!

Prefix the function or method call with the keyword `go` and you will have a new Goroutine running concurrently. Abracadabra!

.code code/goroutines/go_keyword.go /START OMIT/,/END OMIT/

* Goroutines in action - our first magic trick!

Let's start the show - our magician will read our minds. Fingers crossed it will work!

.play code/goroutines/first_routine.go /START OMIT/,/END OMIT/

* Oh no! The magician failed!

Let's have a look at why our previous example didn't work:

- The `main` thread started the magic show
- The `main` thread started the magician goroutine
- The `main` thread had no more work and closed down the magic show
- The `main` thread exited

Our magician goroutine never had the chance to return its results before main shut down the whole program!

When a new Goroutine is started, the goroutine call returns immediately.
It is *non-blocking*.

If the main thread terminates then the program will be terminated and no other Goroutine will run.

* Let's give the magician another chance

.image https://media.giphy.com/media/XGhGacEaO9PQ1Kgck3/giphy.gif _ 350

* Waiting for our goroutines - first magic trick reloaded!

.play code/goroutines/first_routine_sleep.go  /START OMIT/,/END OMIT/

* The magician did his trick!
The magician takes a bow, he's done his trick, but there are some problems:

- The magic show ends a long time after the magician ends = *waste* *of* *resources*
- The sleep is still no guarantee that we will wait for the magician if he is slow = *intermittent* *bug*

We need something better!

.image https://media.giphy.com/media/KOBFnpQdaKChW/giphy.gif _ 400

* The WaitGroup
To ensure that we always wait for all goroutines to finish we can use `sync.WaitGroup`.
This will help us block the main thread until our goroutines finish and help remove that wasteful sleep.

The `sync.WaitGroup`:
- Has three functions: `Add(int)`, `Wait()` and `Done()`
- Has an inner counter that starts at zero and maintains the state of the `WaitGroup`
- Adds `n` to the counter when you call `Add(n)`
- Removes 1 from the counter when you call `Done()`
- `Wait()` blocks the current goroutine and it will be released when the counter is zero

* The WaitGroup Bullet Catch
.play code/waitgroups/wg_magic_show.go  /START OMIT/,/END OMIT/

* Woah, that was a great show!

.image https://media.giphy.com/media/5heRf3BAtwUtwnCc2m/giphy.gif _ 450

* WaitGroup gotchas
aka "Mistakes Adelina's already done many times"

- `WaitGroup` does not need to be passed any params and is usually declared as `var` `wg` `sync.WaitGroup`
- Make sure to use `defer` `wg.Done()` inside your Goroutines. This will ensure you release the `WaitGroup` even if your goroutine errors/panics
- Make sure you pass a pointer to the `WaitGroup` to your Goroutines using `&wg`. Otherwise, a copy will be passed to the function and you will not release anything to the original `main` blocking `WaitGroup`
- Remember that you can `Add(n)` any integer amount, but `Done()` only decreases the counter by 1 and we will not release the `Wait` until the counter reaches 0

* Channels
We saw how we could put on a great magic show with the `sync.WaitGroup`, what if the performers needed to work together and pass props to each other?
In Golang, *channels* have come to our rescue.

Channels can be thought as *pipes* through which Goroutines communicate.

- Each channel has a type it is allowed to transport associated with it.
- `chan` `T` is a channel of type `T`.
- No other type than declared is allowed to be transported using the channel.
- The zero value of a channel is `nil`.
- The channel has to be defined using `make` similar to maps and slices - `make(chan` `T)`
- Channels can be closed to signal that no other values will sent through the pipe - `close(a)`

* Sending and receiving from channel
The syntax to *receive* from a channel `a` is `data` `:=` `<-` `a`.
The arrow points outwards from `a` and hence we are reading from channel `a` and storing the value to the variable `data`.

The syntax to *write* to a channel `a` is `a` `<-` `data`
The arrow points towards `a` and hence we are writing `data` to channel `a`.

And now... it's time for another performance!

.image https://media.giphy.com/media/l2YWs1NexTst9YmFG/giphy.gif _ 350

* The Channel Quick Change Trick

.play code/channels/channel_quick_change.go /START OMIT/,/END OMIT/

* Another successful magic trick!
The magician takes a bow. We have used a channel to get the `main` thread to wait for the juggler to finish his trick.
We have replaced the `sync.WaitGroup` with a channel.
This is possible due to the behaviour of channels. Let's examine this in more detail.

.image https://media.giphy.com/media/S98HinM7FizN29m97L/giphy.gif _ 500

* The behaviour of channels
The reason why we could replace the `sync.WaitGroup` with a channel  is because the read/receive operation of channels is blocking.
This meant that the `main` thread blocked until the `quickChange` sent the value on the channel after the trick!
Alakazam!

.image channel_behaviour.png _ 950

* Buffered channels
Earlier we said that channels were created with `make(chan` `T)`.
This syntax will create a channel or pipe with capacity 0.
Due to the blocking property of channel reads and sends, a single value can be sent, then another one may not be sent until the original value is read.

It is possible to create a channel with a *buffer*. This allows us to send multiple values down the pipe without waiting for each values to travel through.

*Buffered* *channels* can be created by passing an additional capacity parameter to the `make` function which specifies the size of the buffer.

`make(chan` `T,` `capacity)`

* Closing channels and the for range
Senders have the ability to close the channel to notify receivers that no more data will be sent on the channel.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

In the above statement `ok` is true if the value was received by a successful send operation to a channel.
If `ok` is false it means that we are reading from a closed channel. The value read from a closed channel will be the zero value of the channel's type.
A closed channel will *immediately* return when read from.

The *for* *range* form of the for loop can be used to receive values from a channel until it is closed. Once the channel is closed, the loop automatically exits.

* The for range Three card guess
This trick we will need a volunteer to pick three cards...

.play code/channels/for_range_magic_trick.go /START OMIT/,/END OMIT/

* Channels under the hood
We can think of each channel consisting of three FIFO (first in, first out) queues:

- the *receiving* goroutine queue: goroutines in this queue are all in blocking state and waiting to receive values from that channel
- the *sending* goroutine queue: goroutines in this queue are all in blocking state and waiting to send values to that channel
- the *value* queue: holds anywhere between 0 and buffer size amount of values

Each channel internally holds a mutex lock which is used to avoid data races in all kinds of operations.

* Behaviour of channels - revisited

Receiving from a closed channel? Easy, send the zero value of that type.
Sending to a closed channel? Panic as we don't to add the goroutine to the sending queue and block.

.image channel_behaviour.png _ 950

* The select keyword

The `select` statement is used to choose from multiple send/receive channel operations.
The `select` statement blocks until one of the send/receive operation is ready.
If multiple operations are ready, one of them is chosen at random.
The `default` case in a `select` statement is executed when none of the other case is ready. This is generally used to prevent the `select` statement from blocking.

.code code/channels/select_syntax.go /START OMIT/,/END OMIT/

* The Select Cups & Balls trick

.play code/channels/select_magic_trick.go /START OMIT/,/END OMIT/

* Magic show curtain drop
Woah! What an evening of entertainment this has been!
We hope you all enjoyed yourselves!

Our magicians have shown you the following magic tricks:

* Useful links - concurrency & goroutines
A complete journey with goroutines

.link https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c

Concurrency and parallelism in Golang

.link https://medium.com/@tilaklodha/concurrency-and-parallelism-in-golang-5333e9a4ba64

Rob Pike's excellent talk on the Go blog

.link https://blog.golang.org/waza-talk

Golangbot - goroutines

.link https://golangbot.com/goroutines/


* Useful links - channels

Golangbot - channels

.link https://golangbot.com/channels/

Channels in Go

.link https://go101.org/article/channel.html

Golangbot - select

.link https://golangbot.com/select/

* Apprentice to Illusionist: concurrency patterns in Go
.image https://media.giphy.com/media/XKjcTrzElUjsaeQ1eg/giphy.gif _ 600

* Agenda - Magic show II
In the next 45-60min we will cover:

- Signalling to Goroutines that work is finished
- Pipelines
- Buffered channels and worker pools
- Fan in, fan out
- Sample problems & examples
- Making thread safe data structures
- The Go race detector
- Debugger caveats

