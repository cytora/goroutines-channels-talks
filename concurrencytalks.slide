Goroutines & channels
Peeking behind the magic curtain
23 Sep 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have two talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go* (23/09/2020)
introduces and covers the basics.
*Apprentice* *to* *illusionist:* *concurrency* *patterns* (30/09/2020)
takes these basics out for a spin and lets us explore them further.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`.

.link https://godoc.org/golang.org/x/tools/present

As we have not made them public, you can only see them locally.
To see them and run the code examples you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` `-use_playground` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks.slide#1

* Easy magic tricks: concurrency basics in Go
.image https://media.giphy.com/media/JOXzH8WcOgR8PLBqtm/giphy.gif _ 500
* Agenda - Magic show I
In the next 45-60min we will cover:

- Concurrency vs parallelism
- What is a goroutine?
- Common uses of goroutines
- Goroutines basics
- The WaitGroup
- Channels basics
- Closing channels & for range

* Concurrency vs parallelism
Everyone knows that `Go` is designed for concurrency, but what is *concurrency*?

*Concurrency*:
- the composition of independently executing processes
- dealing with lots of things at once
- execution can complete in any given order decided by the scheduler

*Parallelism*:
- the simultaneous execution of (possibly related) computations
- doing lots of things at once
- execution is happening simultaneously and independently


* The concurrent & parallel magician

The magician shuffles the card deck and entertains his audience with jokes using *paralellism*. He is doing both at the same time.

The magician shuffles the card deck and steals a card using *concurrency*. We are not sure the order in which these events happened.

.image https://media.giphy.com/media/UV4liSdOaKdw3V9HGI/giphy.gif _ 350

* What is a Goroutine?
-  In Go, concurrency is achieved by using Goroutines. Goroutines are functions or methods which can run concurrently with other methods and functions
- Goroutines are sometimes called _lightweight_ _threads_
- Goroutines require *2kb* of memory, while threads require *1Mb* (~500x more)
- Unlike threads, they are managed by the `Go` runtime not the OS
- Unlike threads, they are *cooperatively* scheduled and they periodically yield control

.image https://media.giphy.com/media/uNE1fngZuYhIQ/giphy.gif _ 600

* Cool, but why should I care?

Common uses of goroutines are:

- Background processing of large files
- Handling user requests in web servers
- Pushing tracking events/logs in the background

Most importantly, goroutines allow our programs to run more than one function

* The go keyword
Prefix the function or method call with the keyword `go` and you will have a new Goroutine running concurrently. Abracadabra!

.code code/goroutines/go_keyword.go /START OMIT/,/END OMIT/

.image https://media.giphy.com/media/UDjF1zMreMld6/giphy.gif _ 400


* The Goroutine Mentalist trick

Let's start the show - our magician will read our minds. Fingers crossed it will work!

.play code/goroutines/first_routine.go /START OMIT/,/END OMIT/

* Oh no! The magician failed!

Let's have a look at why our previous example didn't work:

- The `main` goroutine started the magic show
- The `main` goroutine started the magician goroutine
- The `main` goroutine had no more work and closed down the magic show
- The `main` goroutine exited

Our magician goroutine never had the chance to return its results before main shut down the whole program!

When a new Goroutine is started, the goroutine call returns immediately.
It is *non-blocking*.

If the main goroutine terminates then the program will be terminated and no other Goroutine will run.

* Let's give the magician another chance

.image https://media.giphy.com/media/XGhGacEaO9PQ1Kgck3/giphy.gif _ 350

* Waiting for our goroutines - the Goroutine Mentalist trick reloaded!

.play code/goroutines/first_routine_sleep.go  /START OMIT/,/END OMIT/

* The magician did his trick!
The magician takes a bow, he's done his trick, but there are some problems:

- The magic show ends a long time after the magician ends = *waste* *of* *resources*
- The sleep is still no guarantee that we will wait for the magician if he is slow = *intermittent* *bug*

We need something better!

.image https://media.giphy.com/media/KOBFnpQdaKChW/giphy.gif _ 400

* The WaitGroup
We can use `sync.WaitGroup` to ensure that the main goroutine waits for other goroutines to finish. This will remove that wasteful sleep and guarantee that we always wait for magic tricks to end.

The `sync.WaitGroup`:

- Has three functions: `Add(int)`, `Wait()` and `Done()`
- Has an inner counter that starts at zero and maintains the state of the `WaitGroup`
- Adds `n` to the counter when you call `Add(n)`
- Removes 1 from the counter when you call `Done()`
- `Wait()` blocks the current goroutine and it will be released when the counter is zero

* The WaitGroup Bullet Catch
.play code/waitgroups/wg_magic_show.go  /START OMIT/,/END OMIT/

* Woah, the magician caught the bullet!
The `sync.WaitGroup` guaranteed that the assistant fires before the magician catches the bullet AND that the main goroutine waited for the trick to end.

.image https://media.giphy.com/media/eIm624c8nnNbiG0V3g/giphy.gif _ 550

* WaitGroup gotchas
aka "Mistakes Adelina's already done many times"

- `WaitGroup` does not need to be passed any params and is usually declared as `var` `wg` `sync.WaitGroup` as shown
- Make sure to use `defer` `wg.Done()` inside your Goroutines. This will ensure you release the `WaitGroup` even if your goroutine errors/panics
- Make sure you pass a pointer to the `WaitGroup` to your Goroutines using `&wg`. Otherwise, a copy will be passed to the function and you will not release anything to the original `main` blocking `WaitGroup`
- Remember that you can `Add(n)` any integer amount, but `Done()` only decreases the counter by 1 and we will not release the `Wait` until the counter reaches 0

* Channels
We saw how we could put on a great magic show with the `sync.WaitGroup`, what if the performers needed to work together?
In Golang, *channels* have come to our rescue. Channels can be thought as *pipes* through which Goroutines communicate.

- Each channel has a type it is allowed to transport associated with it.
- `chan` `T` is a channel of type `T`. No other type than `T` is allowed to be transported using the channel.
- The zero value of a channel is `nil`.
- The channel has to be defined using `make` similar to maps and slices - `make(chan` `T)`
- Channels can be closed to signal that no other values will sent through the pipe - `close(a)`

* Sending and receiving from channel
The syntax to *receive* from a channel `a` is `data` `:=` `<-` `a`.
The arrow points outwards from `a` and hence we are reading from channel `a` and storing the value to the variable `data`.

The syntax to *write* to a channel `a` is `a` `<-` `data`
The arrow points towards `a` and hence we are writing `data` to channel `a`.

And now... it's time for another performance!

.image https://media.giphy.com/media/l2YWs1NexTst9YmFG/giphy.gif _ 350

* The Channel Quick Change Trick

.play code/channels/channel_quick_change.go /START OMIT/,/END OMIT/

* Another successful magic trick!
The magician takes a bow. We have used a channel to get the `main` goroutine to wait for the magician to finish the Quick Change.
We have replaced the `sync.WaitGroup` with a channel.
This is possible due to the behaviour of channels. Let's examine this in more detail.

.image https://media.giphy.com/media/S98HinM7FizN29m97L/giphy.gif _ 500

* The behaviour of channels
The reason why we could replace the `sync.WaitGroup` with a channel  is because the read/receive operation of channels is blocking.
This meant that the `main` goroutine blocked until the `quickChange` sent the value on the channel after the trick!

.image channel_behaviour.png _ 950

* Closing channels and the for range
Senders have the ability to close the channel to notify receivers that no more data will be sent on the channel.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

In the above statement `ok` is true if the value was received by a successful send operation to a channel.
If `ok` is false it means that we are reading from a closed channel. The value read from a closed channel will be the zero value of the channel's type.
A closed channel will *immediately* return when read from.

The *for* *range* form of the for loop can be used to receive values from a channel until it is closed. Once the channel is closed, the loop automatically exits.

* The for range Card Shuffle
.play code/channels/for_range_magic_trick.go /START OMIT/,/END OMIT/

* What a great shuffle!
A channel was used to communicated with the magician and tell him when to stop shuffling. The channel is closed when we are done picking card and the loop exits.
A separate channel was used to ensure that the goroutine finished its work before exiting. `main` waits for a value from this separate channel before exiting.
Closing the channel will make it immediately return the zero value, unblocking `main`

.image https://media.giphy.com/media/Ok2oKUe5Mnq3m60vFJ/giphy.gif _ 350

* Channels under the hood
We can think of each channel consisting of three FIFO (first in, first out) queues:

- the *receiving* goroutine queue: goroutines in this queue are all in blocking state and waiting to receive values from that channel
- the *sending* goroutine queue: goroutines in this queue are all in blocking state and waiting to send values to that channel
- the *value* queue: holds anywhere between 0 and buffer size amount of values (more on buffers in next session)

Each channel internally holds a mutex lock which is used to avoid data races in all kinds of operations.

* Behaviour of channels - revisited

Receiving from a closed channel? Easy, send the zero value of that type
Sending to a closed channel? Panic as we don't to add the goroutine to the sending queue and block it when we know other values are not going to come
A value when there is a goroutine waiting for one? Dequeue that goroutine and give it that value

.image channel_behaviour.png _ 950

* Magic show curtain drop
Woah! What a great show! We hope you all enjoyed yourselves!

Our magicians have shown you the following magic tricks:

- *Mentalist* trick: doing basic work with goroutines and waiting for them to complete with sleep
- *Bullet* *Catch* trick: guarantee goroutine execution completion and order using the `sync.WaitGroup`
- *Quick* *Change* trick: signalling work is completed using channels instead of `sync.WaitGroup` and exploring the blocking behaviour of channel sends/receives
- *Card* *Shuffle* trick: receiving values using the for range as well as closing channels to show work has completed

* Useful links - goroutines
A complete journey with goroutines

.link https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c

Concurrency and parallelism in Golang

.link https://medium.com/@tilaklodha/concurrency-and-parallelism-in-golang-5333e9a4ba64

Rob Pike's excellent talk on the Go blog

.link https://blog.golang.org/waza-talk

Golangbot - goroutines

.link https://golangbot.com/goroutines/

* Useful links - channels

Golangbot - channels

.link https://golangbot.com/channels/

Channels in Go

.link https://go101.org/article/channel.html

Go by example - range over channels

.link https://gobyexample.com/range-over-channels

* See you next week!

.image https://media.giphy.com/media/7yojoQtevjOCI/giphy.gif _ 550

* Apprentice to Illusionist: concurrency patterns in Go
.image https://media.giphy.com/media/XKjcTrzElUjsaeQ1eg/giphy.gif _ 600

* Agenda - Magic show II
In the next 45-60min we will cover:

- The `select` keyword
- Signalling to Goroutines that work is finished
- Buffered channels and worker pools
- Pipelines
- Sample problems & examples
- Making thread safe data structures
- The Go race detector
- Debugger caveats

* The select keyword

The `select` statement is used to choose from multiple send/receive channel operations.
The `select` statement blocks until one of the send/receive operation is ready.
If multiple operations are ready, one of them is chosen at random.
The `default` case in a `select` statement is executed when none of the other case is ready. This is generally used to prevent the `select` statement from blocking.

.code code/channels/select_syntax.go /START OMIT/,/END OMIT/

* The Select Cups & Balls trick

.play code/channels/select_magic_trick.go /START OMIT/,/END OMIT/

* Buffered channels
Earlier we said that channels were created with `make(chan` `T)`.
This syntax will create a channel or pipe with capacity 0.
Due to the blocking property of channel reads and sends, a single value can be sent, then another one may not be sent until the original value is read.

It is possible to create a channel with a *buffer*. This allows us to send multiple values down the pipe without waiting for each values to travel through.

*Buffered* *channels* can be created by passing an additional capacity parameter to the `make` function which specifies the size of the buffer.

`make(chan` `T,` `capacity)`