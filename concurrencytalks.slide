Goroutines & channels
Peeking behind the magic curtain
23 Sep 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have two talks each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go*
introduces and covers the basics.
*Apprentice* *to* *illusionist:* *concurrency* *patterns*
takes these basics out for a spin and lets us explore them further.

.image https://media.giphy.com/media/lluj1cauAlO2vQEm8A/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`, as it allows us to run `Go` code straight into the slide deck.

.link https://godoc.org/golang.org/x/tools/present

To see them and run the code examples locally you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks.slide#1

* Easy magic tricks: concurrency basics in Go
.image https://media.giphy.com/media/JOXzH8WcOgR8PLBqtm/giphy.gif _ 500
* Agenda - Talk I
In the next 45-60min we will cover:

- Concurrency vs parallelism
- What is a goroutine?
- Common uses of goroutines
- Goroutines basics
- The WaitGroup
- Channels
- The Select keyword

* Concurrency vs parallelism
Everyone knows the `Go` is designed for concurrency, but what is it?

*Concurrency*:
- the composition of independently executing processes
- dealing with lots of things at once
- execution can complete in any given order

*Parallelism*:
- the simultaneous execution of (possibly related) computations.
- doing lots of things at once


* The concurrent & parallel magician

The magician cuts the card deck and entertains his audience with jokes using *paralellism*. He is doing both at the same time.

The magician cuts the card deck and steals a card using *concurrency*.
We are not sure the order in which these events happened.

.image https://media.giphy.com/media/UV4liSdOaKdw3V9HGI/giphy.gif _ 350

* What is a Goroutine?

- In Go, concurrency is achieved by using Goroutines. They are functions or methods which can run concurrently with others methods and functions
- Goroutines require *2kb* of memory, while threads require *1Mb* (~500x more)
- Unlike threads, they are managed by the `Go` runtime not the OS
- Unlike threads, they are *cooperatively* scheduled and they periodically yield control

.image https://media.giphy.com/media/uNE1fngZuYhIQ/giphy.gif _ 600

* Cool, but why should I care?

Common uses of goroutines are:

- Background processing of large files
- Handling user requests in web servers
- Pushing tracking events/logs in the background

Let's give it up for our good friends, the goroutines!

.image https://media.giphy.com/media/26gsgZvwuSg2JZybC/giphy.gif _ 550

* Goroutines in action - our first magic trick!

Let's start a goroutine. Fingers crossed it will work!

.play code/goroutines/first_routine.go

* Oh no! The magician failed!

Let's have a look at why our previous example didn't work:

- The `main` thread started the magic show
- The `main` thread started the magician goroutine
- The `main` thread output immediately shut down the magic show
- The `main` thread exited

Our magician goroutine never had the chance to return its results before main shut down the whole program!

When a new Goroutine is started, the goroutine call returns immediately.
Unlike functions, the control does not wait for the Goroutine to finish executing.

If the main Goroutine terminates then the program will be terminated and no other Goroutine will run.

* Let's give the magician another chance

.image https://media.giphy.com/media/XGhGacEaO9PQ1Kgck3/giphy.gif _ 350

* Waiting for our goroutines - first magic trick reloaded!

.play code/goroutines/first_routine_sleep.go  /START OMIT/,/END OMIT/

* The magician did his trick!
The magician takes a bow, he's done his trick, but there are some problems:

- The magic show ends a long time after the magician ends = *waste* *of* *resources*
- The sleep is still no guarantee that we will wait for the magician if he is slow = *intermittent* *bug*

We need something better!

.image https://media.giphy.com/media/KOBFnpQdaKChW/giphy.gif _ 400

* The WaitGroup
To ensure that we always wait for all goroutines to finish we can use `sync.WaitGroup`.
This will help us block the main thread until our goroutines finish and help remove that wasteful sleep.

The `sync.WaitGroup`:
- Has three functions: `Add(int)`, `Wait()` and `Done()`
- Has an inner counter that starts at zero and maintains the state of the `WaitGroup`
- Adds `n` to the counter when you call `Add(n)`
- Removes 1 from the counter when you call `Done()`
- `Wait()` blocks the current goroutine and it will be released when the counter is zero

* The WaitGroup magic show
.play code/waitgroups/wg_magic_show.go  /START OMIT/,/END OMIT/

* Woah, that was a great show!
All the performers did their tricks and then the magic show gracefully ended!

.image https://media.giphy.com/media/5heRf3BAtwUtwnCc2m/giphy.gif _ 450

* WaitGroup gotchas
aka "Mistakes Adelina's already done many times"

- `WaitGroup` does not need to be passed any params and is usually declared as `var` `wg` `sync.WaitGroup`
- Make sure to use `defer` `wg.Done()` inside your Goroutines. This will ensure you release the `WaitGroup` even if your goroutine errors/panics
- Make sure you pass a pointer to the `WaitGroup` to your Goroutines using `&wg`. Otherwise, a copy will be passed to the function and you will not release anything to the original `main` blocking `WaitGroup`
- Remember that you can `Add(n)` any integer amount, but `Done()` only decreases the counter by 1 and we will not release the `Wait` until the counter reaches 0

* Channels

* Further reading - Basics
A complete journey with goroutines

.link https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c

Concurrency and parallelism in Golang

.link https://medium.com/@tilaklodha/concurrency-and-parallelism-in-golang-5333e9a4ba64

Rob Pike's excellent talk on the Go blog

.link https://blog.golang.org/waza-talk

Golangbot - goroutines

.link https://golangbot.com/goroutines/

Golangbot - channels

.link https://golangbot.com/channels/

* Apprentice to Illusionist: concurrency patterns in Go
.image https://media.giphy.com/media/XKjcTrzElUjsaeQ1eg/giphy.gif _ 600

* Agenda - Talk II
In the next 45-60min we will cover:

- Signalling to Goroutines that work is finished
- Pipelines
- Buffered channels and worker pools
- Fan in, fan out
- Sample problems & examples
- Making thread safe data structures
- The Go race detector
- Debugger caveats

