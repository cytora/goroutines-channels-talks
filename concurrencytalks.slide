Goroutines & channels
Peeking behind the magic curtain
23 Sep 2020

Adelina Simion
adelina.simion@cytora.com

* Format of talks
We have two talks/magic shows each 45-60mins.
*Easy* *magic* *tricks:* *concurrency* *basics* *in* *Go* (23/09/2020)
introduces and covers the basics.
*Apprentice* *to* *illusionist:* *concurrency* *patterns* (30/09/2020)
takes these basics out for a spin and lets us explore them further.

.image https://media.giphy.com/media/21T9PmWttOb0EFrrwK/giphy.gif _ 450

* Running slide deck locally
These slides are built with `go` `present`.

.link https://godoc.org/golang.org/x/tools/present

As we have not made them public, you can only see them locally.
To see them and run the code examples you must:

- Have `Go` installed
- Checkout the slides repository

.link https://github.com/cytora/goroutines-channels-talks

- Install present locally with `go` `get` `golang.org/x/tools/cmd/present`
- Run `present` `-use_playground` from the terminal
- View the slides at

.link http://127.0.0.1:3999/concurrencytalks.slide#1

* Easy magic tricks: concurrency basics in Go
.image https://media.giphy.com/media/JOXzH8WcOgR8PLBqtm/giphy.gif _ 500
* Agenda - Magic show I
In the next 45-60min we will cover:

- Concurrency vs parallelism
- What is a goroutine?
- Common uses of goroutines
- Goroutines basics
- The Mutex & the WaitGroup
- Channels basics

* Concurrency vs parallelism
Everyone knows that `Go` is designed for concurrency, but what is *concurrency*?

*Concurrency*:
- the composition of independently executing processes
- dealing with lots of things at once
- execution can complete in any given order decided by the scheduler

*Parallelism*:
- the simultaneous execution of (possibly related) computations
- doing lots of things at once
- execution is happening simultaneously and independently


* The concurrent & parallel magician

The magician shuffles the card deck and entertains his audience with jokes using *paralellism*. He is doing both at the same time.

The magician shuffles the card deck and steals a card using *concurrency*. We are not sure the order in which these events happened.

.image https://media.giphy.com/media/UV4liSdOaKdw3V9HGI/giphy.gif _ 350

* What is a Goroutine?
-  In Go, concurrency is achieved by using Goroutines. Goroutines are functions or methods which can run concurrently with other methods and functions
- Goroutines are sometimes called _lightweight_ _threads_
- Goroutines require *2kb* of memory, while threads require *1Mb* (~500x more)
- Unlike threads, they are managed by the `Go` runtime not the OS
- Unlike threads, they are *cooperatively* scheduled and they periodically yield control

There are other differences between threads and goroutines, but this is outside the scope of our discussion/magic show today.

* Cool, but why should I care?

Common uses of goroutines are:

- Background processing of large files
- Handling user requests in web servers
- Pushing tracking events/logs in the background

Most importantly, goroutines allow our programs to run more than one function.
Goroutines are absolutely essential to performant production grade software.

.image https://media.giphy.com/media/Nx85vtTY70T3W/giphy.gif _ 400

* The go keyword
Prefix the function or method call with the keyword `go` and you will have a new Goroutine running concurrently with the main goroutine.
Abracadabra! Let the magic tricks begin!

.code code/goroutines/go_keyword.go /START OMIT/,/END OMIT/

.image https://media.giphy.com/media/UDjF1zMreMld6/giphy.gif _ 400


* The Goroutine Mentalist trick

Let's start the show - our magician will read our minds. Fingers crossed it will work!

.play code/goroutines/first_routine.go /START OMIT/,/END OMIT/

* Oh no! The magician failed!

Let's have a look at why our previous example didn't work:

- The `main` goroutine started the magic show
- The `main` goroutine started the magician goroutine
- The `main` goroutine had no more work and closed down the magic show
- The `main` goroutine exited

Our magician goroutine never had the chance to return its results before main shut down the whole program!

When a new Goroutine is started, the goroutine call returns immediately. It is *non-blocking* and allows the goroutine that it is created from to continue its work.

If the main goroutine terminates then the program will be terminated and no other Goroutine will run.

* Let's give the magician another chance

.image https://media.giphy.com/media/XGhGacEaO9PQ1Kgck3/giphy.gif _ 350

* Waiting for our goroutines - the Goroutine Mentalist trick reloaded!

.play code/goroutines/first_routine_sleep.go  /START OMIT/,/END OMIT/

* The magician did his trick!
The magician takes a bow, he's done his trick, but there are some problems:

- The magic show ends a long time after the magician ends = *waste* *of* *resources*
- The sleep is still no guarantee that we will wait for the magician if he is slow = *intermittent* *bug*

We need something better!

.image https://media.giphy.com/media/KOBFnpQdaKChW/giphy.gif _ 400

* The sync package
We will discuss two synchronization mechanisms from the `sync` package today:

- the `WaitGroup`
- the `Mutex`

From the `godocs`:

.code code/waitgroups/sync_documentation.go /START OMIT/,/END OMIT/

.link https://golang.org/pkg/sync

A further discussion of synchronization vs channels will take place in the second presentation/magic show, we are only interested in usage today.

* Magic refresher - pointers & argument passing
Before we go further into the perilous world of syncronization, let's recount one of the basic magic school lessons about pointers & argument passing:

- A *pointer* is a memory address to a variable. The `iptr:=&i` syntax gives the memory address of `i`, i.e. a pointer to `i` is assigned to variable `iptr`
- The `*iptr` syntax *dereferences* the pointer from its memory address to the current value at that address
- Arguments to functions are passed by copy in Go. Any changes we make to the copy will be lost, as the copy is destroyed by the garbage collector once the function exits
- Passing pointers to functions allow us to make permanent changes to variables
- Pointers themselves are passed by copy, so reassigning the pointer to a different variable address will not be a persist outside the scope of the function

* The Rabbit Hat-trick

.play code/waitgroups/pointers_argument_passing.go  /START OMIT/,/END OMIT/

* A successful classic hat trick!
As we saw in the hat trick, assigning the rabbit to the hat only succeeds once we passed a pointer to the hat. Otherwise, the rabbit is put inside a copy of the hat, which only lives inside function scope, and the trick fails!

.image https://media.giphy.com/media/MFlhfP81IpKgaN50fq/giphy.gif _ 400

* The Bullet Catch
In this trick, timing is everything! The assistant fires a gun at the magician and he *magically* catches the bullet. He then reveals the caught bullet and takes a bow.

.play code/waitgroups/failed/wg_magic_show_failed.go  /START OMIT/,/END OMIT/

* Another failed trick!
The magician made the career ending mistake of revealing the bullet before the gun was fired. What a disaster!

Remember that the Go runtime is the one that decides the order in which Goroutines execute. Even though we start the `assistant` goroutine before the `magician` goroutine, they can be executed in any order.
The Go runtime is the boss of the goroutines, not us!

.image https://media.giphy.com/media/li0dswKqIZNpm/giphy.gif _ 400

* The WaitGroup
We can use `sync.WaitGroup` to ensure that goroutines wait for each other to finish.

The `sync.WaitGroup`:

- Has three functions: `Add(int)`, `Wait()` and `Done()`
- Has an inner counter that starts at zero and maintains the state of the `WaitGroup`
- Adds `n` to the counter when you call `Add(n)`
- Removes 1 from the counter when you call `Done()`
- `Wait()` blocks the current goroutine and it will be released when the counter is zero

* The WaitGroup Bullet Catch
.play code/waitgroups/wg_magic_show.go  /START OMIT/,/END OMIT/

* Woah, the magician caught the bullet!
The `sync.WaitGroup` guaranteed that the assistant fires before the magician catches the bullet AND that the main goroutine waited for the trick to end.

.image https://media.giphy.com/media/eIm624c8nnNbiG0V3g/giphy.gif _ 550

* WaitGroup gotchas
aka "Mistakes Adelina's already done many times"

- `WaitGroup` does not need to be passed any params and is usually declared as `var` `wg` `sync.WaitGroup` as shown
- Make sure to use `defer` `wg.Done()` inside your Goroutines. This will ensure you release the `WaitGroup` even if your goroutine errors/panics
- Make sure you pass a pointer to the `WaitGroup` to your Goroutines using `&wg`. Otherwise, a copy will be passed to the function and you will not release anything to the original `main` blocking `WaitGroup`
- Remember that you can `Add(n)` any integer amount, but `Done()` only decreases the counter by 1 and we will not release the `Wait` until the counter reaches 0

* The Infinite Hat Trick - the hat
Let's try the hat trick again with multiple items. Multiple performers will place items in a magically infinite hat!

.code code/mutex/infinite_hat.go /START OMIT/,/END OMIT/

* The Infinite Hat Trick - the trick

.play code/mutex/failed/mutex_magic_show.go /START OMIT/,/END OMIT/

* Oh no! The hat is missing items!
Each goroutine arriving to place items in the hat overwrote each other's items and some items were lost. Now, that's some unintentional magic!

.image https://media.giphy.com/media/z1bMHX8k9Z3yg/giphy.gif _ 350

* The Mutex
When a program runs concurrently, the parts of code which modify shared resources should not be accessed by multiple Goroutines at the same time.
In our case, the performers were modifying the hat contents, which was the share resource. This was the *critical* section of the hat trick.

The `sync.Mutex` is used to provide a locking mechanism:

- The `sync.Mutex` has 2 methods: `Lock` and `Unlock`
- Any code that is present between a call to `Lock` and `Unlock` will be executed by only one Goroutine. This prevents intermittent bugs and inconsistent results
- If one Goroutine already holds the lock and if a new Goroutine is trying to acquire a lock, the new Goroutine will be blocked until the mutex is unlocked
- Mutexes are used to make *threadsafe* structs

* The Mutex Infinite Hat Trick - the hat
We will make our infinite hat thread safe with a mutex so only one performer can place items in it at a time.

.code code/mutex/mutex_infinite_hat.go /START OMIT/,/END OMIT/

* The Mutex Infinite Hat Trick - the trick

.play code/mutex/success/mutex_magic_show.go /START OMIT/,/END OMIT/

* Oh woah! Maybe that hat really is infinite!
The mutex made sure that each goroutine gained control of the hat and then placed the item in it. The goroutines are no longer able to overwrite/remove each other's items.

.image https://media.giphy.com/media/2Fazg4XrLLmoGqwMg/giphy.gif _ 500

* Channels
We saw how we could put on a great magic show with the `sync.WaitGroup` and `sync.Mutex`, but channels provide a more elegant way for goroutines to communicate and synchronize at the same time.

*Channels* can be thought of as *pipes* through which Goroutines communicate.

- Each channel has a type it is allowed to transport associated with it.
- `chan` `T` is a channel of type `T`. No other type than `T` is allowed to be transported using the channel.
- The zero value of a channel is `nil`.
- The channel has to be defined using `make` similar to maps and slices - `make(chan` `T)`
- Channels can be closed to signal that no other values will sent through the pipe - `close(a)`

* Sending and receiving from channel
The syntax to *receive* from a channel `a` is `data` `:=` `<-` `a`.
The arrow points outwards from `a` and hence we are reading from channel `a` and storing the value to the variable `data`.

The syntax to *write* to a channel `a` is `a` `<-` `data`
The arrow points towards `a` and hence we are writing `data` to channel `a`.

And now... it's time for another performance!

.image https://media.giphy.com/media/l2YWs1NexTst9YmFG/giphy.gif _ 350

* The Channel Quick Change Trick

.play code/channels/channel_quick_change.go /START OMIT/,/END OMIT/

* Another successful magic trick!
We have used a channel to get the `main` goroutine to wait for the magician to finish the Quick Change. We have replaced the `sync.WaitGroup` with a channel.

This is possible due to the behaviour of channels. Let's examine this in more detail.

.image https://media.giphy.com/media/S98HinM7FizN29m97L/giphy.gif _ 500

* The behaviour of channels
The reason why we could replace the `sync.WaitGroup` with a channel  is because the read/receive operation of channels is blocking.
This meant that the `main` goroutine blocked until the `quickChange` sent the value on the channel after the trick!

.image channel_behaviour.png _ 950

* Channels under the hood
We can think of each channel consisting of three FIFO (first in, first out) queues:

- the *receiving* goroutine queue: goroutines in this queue are all in blocking state and waiting to receive values from that channel
- the *sending* goroutine queue: goroutines in this queue are all in blocking state and waiting to send values to that channel
- the *value* queue: holds anywhere between 0 and buffer size amount of values (more on buffers in next session)

Each channel internally holds a mutex lock which is used to avoid data races in all kinds of operations.

* Behaviour of channels - continued

Receiving from a closed channel? Easy, send the zero value of that type
Sending to a closed channel? Panic as we don't to add the goroutine to the sending queue and block it when we know other values are not going to come
A value when there is a goroutine waiting for one? Dequeue that goroutine and give it that value

.image channel_behaviour.png _ 950

* Magic show curtain drop
Woah! What a great show! We hope you all enjoyed yourselves!

Our magicians have shown you the following magic tricks:

- *Mentalist* trick: doing basic work with goroutines and waiting for them to complete with sleep
- *Infinite* *Hat* trick: ensure goroutines acquire orderly control of shared resources
- *Bullet* *Catch* trick: guarantee goroutine execution completion and order using the `sync.WaitGroup`
- *Quick* *Change* trick: signalling work is completed using channels instead of `sync.WaitGroup` and exploring the blocking behaviour of channel sends/receives

* Useful links - goroutines
A complete journey with goroutines

.link https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c

Concurrency and parallelism in Golang

.link https://medium.com/@tilaklodha/concurrency-and-parallelism-in-golang-5333e9a4ba64

Rob Pike's excellent talk on the Go blog

.link https://blog.golang.org/waza-talk

Golangbot - goroutines

.link https://golangbot.com/goroutines/


* Useful links - channels

Golangbot - mutexes

.link https://golangbot.com/mutex/

Golangbot - channels

.link https://golangbot.com/channels/

Channels in Go

.link https://go101.org/article/channel.html

* See you next week!

.image https://media.giphy.com/media/7yojoQtevjOCI/giphy.gif _ 550

* Apprentice to Illusionist: concurrency patterns in Go
.image https://media.giphy.com/media/XKjcTrzElUjsaeQ1eg/giphy.gif _ 600

* Agenda - Magic show II
In the next 45-60min we will cover:

- Closing channels and the for range
- The `select` keyword
- Signalling to Goroutines that work is finished
- Buffered channels and worker pools
- Pipelines
- Sample problems & examples
- Making thread safe data structures
- The Go race detector
- Debugger caveats

* Closing channels and the for range
Senders have the ability to close the channel to notify receivers that no more data will be sent on the channel.
Receivers can use an additional variable while receiving data from the channel to check whether the channel has been closed.

`v,` `ok` `:=` `<-ch`

In the above statement `ok` is true if the value was received by a successful send operation to a channel.
If `ok` is false it means that we are reading from a closed channel. The value read from a closed channel will be the zero value of the channel's type.
A closed channel will *immediately* return when read from.

The *for* *range* form of the for loop can be used to receive values from a channel until it is closed. Once the channel is closed, the loop automatically exits.

* The for range Card Shuffle
.play code/channels/for_range_magic_trick.go /START OMIT/,/END OMIT/

* What a great shuffle!
A channel was used to communicated with the magician and tell him when to stop shuffling. The channel is closed when we are done picking card and the loop exits.
A separate channel was used to ensure that the goroutine finished its work before exiting. `main` waits for a value from this separate channel before exiting.
Closing the channel will make it immediately return the zero value, unblocking `main`

.image https://media.giphy.com/media/Ok2oKUe5Mnq3m60vFJ/giphy.gif _ 350

* The select keyword

The `select` statement is used to choose from multiple send/receive channel operations.
The `select` statement blocks until one of the send/receive operation is ready.
If multiple operations are ready, one of them is chosen at random.
The `default` case in a `select` statement is executed when none of the other case is ready. This is generally used to prevent the `select` statement from blocking.

.code code/channels/select_syntax.go /START OMIT/,/END OMIT/

* The Select Cups & Balls trick

.play code/channels/select_magic_trick.go /START OMIT/,/END OMIT/

* Buffered channels
Earlier we said that channels were created with `make(chan` `T)`.
This syntax will create a channel or pipe with capacity 0.
Due to the blocking property of channel reads and sends, a single value can be sent, then another one may not be sent until the original value is read.

It is possible to create a channel with a *buffer*. This allows us to send multiple values down the pipe without waiting for each values to travel through.

*Buffered* *channels* can be created by passing an additional capacity parameter to the `make` function which specifies the size of the buffer.

`make(chan` `T,` `capacity)`